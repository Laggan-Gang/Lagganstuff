<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "https://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html lang="tlh" xmlns="https://www.w3.org/1999/xhtml">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>13 DAYS OF LAGGAN HOLIDAYS</title>
	<link rel="stylesheet" href="https://unpkg.com/sanitize.css" media="print" onload="this.media='all'" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/comic-mono@0.0.1/index.css" media="print" onload="this.media='all'" />
	<link rel="stylesheet" href="secrets.css" media="print" onload="this.media='all'" />
	<link rel="icon" href="favicon.ico">
	<style type="text/css">
		body {
			padding: 0;
		}
		#behållare {
			width: 100vw;
			height: 100vh;
			overflow: hidden;
		}
		#nedräkning, #fotnot, .nedräkning {
			white-space: nowrap;
			text-align: center;
		}
		#nedräkning, .nedräkning {
			top: 35%;
			font-size: 13vw;
		}
		#fotnot {
			font-size: 4vw;
		}
		#omslagspappret {
			position: relative;
			/* background-image: url("/lagganmas/bakgrund.jpg"); */
			background-size: cover;
			width: 100%;
			height: 100%;
			/* width: 1920px; */
			/* height: 1080px; */
			margin: 0 auto;
			overflow-y: auto;
		}
		#snön, #Зареждане {
			background-size: cover;
			display: block;
			position: fixed;
			left: 0;
			top: 0;
			right: 0;
			bottom: 0;
		}
		#Зареждане {
			display: fixed;
			background: #000;
			overflow: hidden;
		}
		.sara {
			position: absolute;
			background-image: url("/lagganmas/lina.png");
			background-size: cover;
			/* padding-top: 150%; */
			width: 2vw;
			height: 3vw;
		}
		.date {
			display: inline-block;
			width: 100%;
			white-space: nowrap;
			text-align: center;
		}
		.omslagspapper {
			width: 100%;
			overflow-x: auto;
		}
		#kalendarium {
			display: inline-block;
			background: rgba(0,0,0,0.2);
			padding: 10px;
			width: 1400px;
			margin: 0 auto 0;
			display: grid;
			grid-gap: 5px;
			align-items: baseline;
			grid-template-columns: repeat(8, 1fr);
		}
		#kalendarium>div {
			border: 2px solid;
			padding: 5px;
			place-self: stretch;
		}
		#kalendarium>:nth-child(16n + 1),
		#kalendarium>:nth-child(16n + 3),
		#kalendarium>:nth-child(16n + 5),
		#kalendarium>:nth-child(16n + 7),
		#kalendarium>:nth-child(16n + 9),
		#kalendarium>:nth-child(16n + 11),
		#kalendarium>:nth-child(16n + 13),
		#kalendarium>:nth-child(16n + 15)
		{
			border-color: red;
			border-style: dashed;
		}
		#kalendarium>:nth-child(16n + 2),
		#kalendarium>:nth-child(16n + 4),
		#kalendarium>:nth-child(16n + 6),
		#kalendarium>:nth-child(16n + 8),
		#kalendarium>:nth-child(16n + 10),
		#kalendarium>:nth-child(16n + 12),
		#kalendarium>:nth-child(16n + 14),
		#kalendarium>:nth-child(16n + 16)
		{
			border-color: green;
			border-style: dotted;
		}
		#kalendarium>:nth-child(9n), #kalendarium>.noop {
			padding: 0px;
		}
		#kalendarium>.noop {
			border: none;
		}
		#kalendarium>.spacer {
			grid-column: 1 / span 8;
			text-align: center;
		}
		#kalendarium>.minigame {
			grid-column: 2 / span 3;
		}
		#kalendarium>.minigame2 {
			grid-column: 6 / span 3;
		}
		ul.festive>:nth-child(even), .red {
			color: red;
		}
		ul.festive>:nth-child(odd), .green {
			color: green;
		}
		.minigame {
			margin: 50px auto;
			padding: 20px;
			background: rgba(0,0,0,0.2);
		}
	</style>
	<script type="text/javascript">
		skit_i_animering = 1
	</script>
	<!-- <script src="https://greggman.github.io/webgl-lint/webgl-lint.js" crossorigin></script> -->
	<script type="text/javascript" src="UngeMozartdenjäveln.js"></script>
</head>

<body>
	<div id="behållare">
		<div id="snön"></div>
		<div id="omslagspappret">
			<div id="tjockis"></div>
			<div id="nedräkning">69 69:69:42.5</div>
			<div id="fotnot"><h1>Snart blir vi farliga</h1></div>
			<div class="omslagspapper">
				<div id="kalendarium">
					<div>Vecka</div>
					<div>Måndag</div>
					<div>Tisdag</div>
					<div>Onsdag</div>
					<div>Torsdag</div>
					<div>Fredag</div>
					<div>Lördag</div>
					<div>Söndag</div>
					<div>Vecka 51</div>
					<div></div>
					<div title="Osu christmas party"><span class="date">21st</span><br />Lagganmas <span class="red">christmas</span><br /><span class="green">carols</span> edition<br />C/O <span class="disc_jockey">@borzoi#8259</span></div>
					<div></div>
					<div></div>
					<div title="SANTA TIME"><span class="date">24th</span><br />CHRISTMAS</div>
					<div title="DEATH OF AOC"><span class="date">25th</span><br />End of <a href="#spaghooti">advent of code</a><br /><span style="font-style: italic;"><a href="#spaghooti" class="red">nominations</a> <span class="green">starts</span></span></div>
					<div></div>
					<div>Vecka 52</div>
					<div></div>
					<div></div>
					<div title="Electric boogaloo"><span class="date">29th</span><br />Preliminary date for Laggan christmas melee tournament.</div>
					<div></div>
					<div title="New years eve"><span class="date">31st</span><br />New years eve</div>
					<div title="International hangover day"><span class="date">1st</span>Laggan international <span class="red">hangover</span> day.<br /><a href="#jeebus">Lagganmas nominations opens</a></div>
					<div title="Lagganmas of code"><span class="date">2nd</span><br><a href="#spaghooti" class="red">Lagganmas codeawards</a> voting opens</div>
					<div>Vecka 1</div>
					<div></div>
					<div title="Lagganmas spirit"><span class="date">4th</span><br /><a href="#jeebus" class="green">Lagganmas spirit</a> voting opens.</div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div>Vecka 2</div>
					<div></div>
					<div></div>
					<div><span class="date">12th</span><br /><a href="#spaghooti" class="red">Voting</a> <a href="#jeebus" class="green">closes</a></div>
					<div></div>
					<div></div>
					<div><span class="date">15th</span><br />AWARDS DAY</div>
					<div></div>
				</div>
			</div>
			<div class="omslagspapper" style="text-align: center">
				<div style="display: inline-block; margin: 50px auto;">
					<div class="spacer"><h1>MINIGAMES</h1></div>
					<div class="minigame" id="spaghooti">
						<h2><a href="https://adventofcode.com/">Advent of Code</a></h2>
						Advent of Code is a series of coding challenges that run through december.<br />
						We have our own leaderboard: 1149057-9ebdf1ad<br />
						<br />
						And on the 26th, when the challenge is over, nominations will open for our own Laggan Code Awards 2021<br />
						We will be competing in 013 different categories<br />
						Categories in <span class="red">red</span> are for your entire solution-set.
						Categories in <span class="green">green</span> are for a single day challenge.
						<ul style="width: 500px; margin: 15px auto; text-align: left; font-size: 20px;">
							<li class="red">Cleanest code</li>
							<li class="red">Ugliest code</li>
							<li class="red">Most unconventional repo structure</li>
							<li class="red">Best swenglish (Non-english code)</li>
							<li class="green">Weirdest solution</li>
							<li class="green">My eyes</li>
							<li class="green">Best spaghetti</li>
							<li class="green">Best commit message</li>
							<li class="green">Most novel solution</li>
							<li class="green">People's choice</li>
						</ul>
						Every member of laggan can vote in each category, and submit their own solutions to each problem.<br />
						Voting employs an honor system in that I trust that you don't vote for your own solution unless you think it deserves it.<br />
						Voting will be that you need to rank submitted solutions in each category by order of preference from best to worst fitting.<br />
						People should get style-points for avoiding the "proper" way of doing things in all categoriest.<br />
						No further clarification on the categories will be provided<br />
						More categories may be entered at any point.<br />
						Code may be written up until voting starts.<br /><br />
						We will also be voting on <span class="red" style="font-size: 20px;">Most helpful senpai</span><br />
						which is a people's choice on who gave the best mentorship during the AOC time.<br />
						Prizes may or may not be given out.
					</div>
					<div class="minigame" id="jeebus">
						<h2>The lagganmas spirit</h2>
						We are all very creative people in laggan, so for this holiday<br />
						season I'm going to be awarding that creativity.

						This is similar to the Advent of Code challenge, <br />
						in that we will have a bunch of categories you can win prizes in:<br />

						<ul class="festive" style="width: 500px; margin: 15px auto; text-align: left; font-size: 20px;">
							<li><h3><a href="#όλυμπος">Greatest όλυμπος</a></h3></li>
							<li><h3><a href="#gingerblock">Best pepparblockshus</a></h3></li>
							<li><h3><a href="#dota">Best christmas outfit</a></h3></li>
							<li><h3><a href="#dota2">Best yapos call</a></h3></li>
							<li><h3><a href="#satisfactory">Santa's factory</a></h3></li>
							<li><h3><a href="#laggan">Hardest worker for laggan</a></h3></li>
						</ul>


						Every member of laggan can vote in each category, and submit their own entries to each problem.<br />
						Voting employs an honor system in that I trust that you don't vote for your own submission unless you think it deserves it.<br />
						Voting will be that you need to rank submitted solutions in each category by order of preference from best to worst fitting.<br />
						More categories may be added at any point.<br />
						Bonus points will always be given for laggan references or other dankness.<br />
						Prizes will be given out at santas discretion.
					</div>
					<div class="minigame" id="όλυμπος">
						<h2>The spirit of όλυμπος</h2>
						<p>
							During the holidays we will all have time off, santa may give winners of fun games prizes at his discretion.<br />
							At the end of the holiday season we will vote for the greatest olympian,<br />
							a people's choice of who was best in show playing slapstick or arranging fun times to be had.
						</p>
					</div>
					<div class="minigame" id="gingerblock">
						<h1>Best pepparblockshus</h1>
						<p>
							This challenge is to build the best christmas village / gingerbread house<br />
							or other interpretation of the challenge in an open world:y game, think Minecraft<br />
							The Sims, etc.<br />
							<br />
							And we're looking for creativity here, loading up sims<br />
							and adding a christmas tree and mistletoe isn't worthy of winning.
						</p>
					</div>
					<div class="minigame" id="dota">
						<h1>Best christmas outfit</h1>
						<p>
							This challenge will be to provide your own loadout / outfit / skin selection / custom skin<br />
							that is <span class="red" style="font-style: italic;">festive</span>.<br />
							
							Negative points will be given to people who use blatant christmas items to achieve this.<br />
							You won't win by equipping a santa hat and a red shirt. I want to see creativity here.
						</p>
					</div>
					<div class="minigame" id="dota2">
						<h1>Yapos challenge</h1>
						<p>
							Here we will vote for the best yapos call that has been added to <a href="https://github.com/Laggan-Gang/Claes">elevrådsordföranden</a><br />
							or custom laggan christmas tune. The yapos call should be 7 or 20 seconds long.
						</p>
					</div>
					<div class="minigame" id="satisfactory">
						<h1>Santa's factory</h1>
						<p>
							Most sweatshoppy automation solution in a game. I.E: Minecraft / Satisfactory / Factorio.
						</p>
					</div>
					<div class="minigame" id="rapper">
						<h1>Best christmas rhyme</h1>
						<p>
							Write a rhyme, limerick, haiku, cockn rap song or other lyrical masterpiece.<br />
							Bonus points will be given for dankness, göteborgare, performance etc.
						</p>
					</div>
					<div class="minigame" id="laggan">
						<h1>Thank you X</h1>
						<p>
							This is a category where you're not allowed to nominate yourself or santa.<br />
							It is for us to thank the people who have made laggan a great place to hang out during<br />
							<span style="font-style: italic;">these</span> <span style="text-decoration:underline">trying</span> <span class="red">tajms</span>.
						</p>
					</div>
				</div>
			</div>
		</div>
	</div>
	<button style="position: fixed; bottom: 5px; right: 5px;" onclick="nej()">Stäng av snön</button>
	<div id="Зареждане">
		<div class="nedräkning">LADDAR<br />Зареждане</div>
		<div class="sara" style="top:49.5%; left: 45.3%; display: none;"></div>
	</div>
</body>
<script type="text/javascript">
	// kraftigt inspirerad av https://github.com/bsehovac/shader-program

	behållaren = hämtaRadiatorEfterLegitimation('snön')
	målarduken = skapaElement( målarduk )
	mb = målarduken[hämtaSammanhang]( nätmb, { antialias: sant } )

	texturerna = {}
	texturerAttLaddaTotti = 0;
	texturerAttLadda = 0;
	saror = [];
	Зареждане = hämtaRadiatorEfterLegitimation("Зареждане")
	laddStorlek = { x: 0, y: 0 }
	bäst = "sara";

	påomskalning = () => {
        laddFyrkanten = Зареждане[hämtaGränsKlientFyrkant]()
        laddStorlek.x = laddFyrkanten[bredd] - 0.02 * alltsåNånslagsGränsFårDetVälVa.x;
        laddStorlek.y = laddFyrkanten[höjd] - 0.03 * alltsåNånslagsGränsFårDetVälVa.y;
    }
    påomskalning()
    Зареждане[läggTillHändelseSpanare](omskalning, påomskalning)

	ritaEnSara = (sara) => {
		sara.φ += sara.riktning * slumpa(0, 1, i => 1 - i * i)
		sara.φφ = (τ/360) * sara.φ
		sara.r += Matte.min(0.5, Matte.max(0, slumpa(0, 0.01) * sara.riktning))

		i = slumpa(0, 1000000, x => 1 - x * x * x)
		sara.snurrilurr += sara.riktning * slumpa(0, 5);
		om(i > 999995, () => { sara.riktning *= -1 })


		sara[stil][toppen] = (Matte.sin(sara.φφ) * sara.r + 0.5) * laddStorlek.y + tavelPlättar
		sara[stil][vänster] = (Matte.cos(sara.φφ) * sara.r + 0.5) * laddStorlek.x + tavelPlättar
		sara[stil][spannBlankett] = `${skalaX}(${sara.riktning}) ${rotera}(${sara.snurrilurr}deg)`;
	}
	laddningFärdig = () => {
		sara = skapaElement(låda);
		saror[knuffa](sara);
		Зареждане[bifogaBarn](sara);

		sara[socioEkonomiskTillhörighet] = bäst
		r = slumpa(0, 0.5)
		φ = slumpa(0, 360);
		sara.φ = φ;
		sara.r = r;
		sara.snurrilurr = slumpa(-360, 360)
		sara.riktning = blanda([1, -1])[0]

		ritaEnSara(sara)
	}

	springSaraSpring = () => {
		saror[förVarje](ritaEnSara)

		merAttLadda = texturerAttLadda > 0 || obligatoriskaSaror > 0
		om(merAttLadda, () => sättVäntetid(springSaraSpring, 150), () => {
			Зареждане[stil][skärm] = ingen
		})
	}
	sättVäntetid(springSaraSpring, 150)

	obligatoriskaSaror = golva(slumpa(20, 50, x => x*x*x));
	obligatoriskSara = () => {
		laddningFärdig();

		om(texturerAttLadda < 2, () => obligatoriskaSaror--);
		notera(`sara skapad, ${obligatoriskaSaror} kvar`)
		om(obligatoriskaSaror > 0, () => {
			sättVäntetid(obligatoriskSara, texturerAttLadda == 0 ?slumpa(100, 2000, i => i*i) : 1000)
		}, () => obligatoriskaSaror)
	}
	obligatoriskSara();

	skapaBildTextur = (namn, källPlats, element = falskt) => {
		bilden = nyBild(källPlats)
		texturerAttLadda++;
		texturerAttLaddaTotti++;
		bilden[läggTillHändelseSpanare](ladda, () => {
			om(element, ()=>{ hämtaRadiatorEfterLegitimation(element)[stil][bakgrundsBild] = `${sökväg}(${källPlats})` })

			texturerAttLadda--;
			laddningFärdig();
			notera(`${källPlats} laddad, ${texturerAttLadda} kvar`)
		})
		texturerna[namn] = bilden;
	}

	skapaBildTextur("bakgrunden", '/lagganmas/bakgrund.jpg', "snön")
	skapaBildTextur("solen", '/lagganmas/solen.png')

	om(mb, () => {
		behållaren[bifogaBarn](målarduken)
		
		snöProgram = {};
		snöProgram.vertexSkuggare = mb[skapaSkuggare](mb[VERTEX_SKUGGARE])
		mb[skuggarKälla](snöProgram.vertexSkuggare, `
			${noggrannhet} ${högn} ${flyttal};

			${egenskap} ${quadvektor} e_plats;
			${egenskap} ${quadvektor} e_nyans;
			${egenskap} ${trivektor} e_cirkulation;
			${egenskap} ${trivektor} e_hastighet;
			${egenskap} ${flyttal} e_storlek;

			${likformig} ${flyttal} l_tid;
			${likformig} ${bivektor} l_noggrannhet;
			${likformig} ${quadmatris} l_projicering;
			${likformig} ${trivektor} l_jordStorlek;
			${likformig} ${flyttal} l_newton;
			${likformig} ${flyttal} l_vinden;

			${brokig} ${quadvektor} v_nyans;
			${brokig} ${flyttal} v_cirkulation;

			${tomhet} ${huvud}() {

				v_nyans = e_nyans;
				v_cirkulation = e_cirkulation.x + l_tid * e_cirkulation.y;

				${trivektor} plats = e_plats.xyz;

				plats.x = mod(plats.x + l_tid + l_vinden * e_hastighet.x, l_jordStorlek.x * 2.0) - l_jordStorlek.x;
				plats.y = mod(plats.y - l_tid * e_hastighet.y * l_newton, l_jordStorlek.y * 2.0) - l_jordStorlek.y;

				plats.x += sin(l_tid * e_hastighet.z) * e_cirkulation.z;
				plats.z += cos(l_tid * e_hastighet.z) * e_cirkulation.z;

				${mb_Plats} = l_projicering * ${quadvektor}( plats.xyz, e_plats.w );
				${mb_PunktStorlek} = ( e_storlek / ${mb_Plats}.w ) * 100.0;

			}`)
		mb[kompileraSkuggare](snöProgram.vertexSkuggare)
		om(!mb[hämtaSkuggVariabel](snöProgram.vertexSkuggare, mb[KOMPILATIONS_STATUS]), () => {
			notera(mb[hämtaSkuggDeklarationsLoggbok](snöProgram.vertexSkuggare))
			mb[utplånaSkuggare](snöProgram.vertexSkuggare)
			kasta("nåt gick fel vid skapandet av snöProgram.vertexskuggaren")
		})
		notera("snöProgram.vertexSkuggare initierad")

		snöProgram.skärvSkuggare = mb[skapaSkuggare](mb[SKÄRV_SKUGGARE])
		mb[skuggarKälla](snöProgram.skärvSkuggare, `
			${noggrannhet} ${högn} ${flyttal};

			${likformig} ${provtagare2D} u_struktur;

			${brokig} ${quadvektor} v_nyans;
			${brokig} ${flyttal} v_cirkulation;

			${tomhet} ${huvud}() {

				${bivektor} cirkulerad = ${bivektor}(
					cos(v_cirkulation) * (${mb_PunktPlats}.x - 0.5) + sin(v_cirkulation) * (${mb_PunktPlats}.y - 0.5) + 0.5,
					cos(v_cirkulation) * (${mb_PunktPlats}.y - 0.5) - sin(v_cirkulation) * (${mb_PunktPlats}.x - 0.5) + 0.5
				);

				${quadvektor} admin = ${struktur2D}(u_struktur, cirkulerad);

				${mb_SkärvNyans} = ${quadvektor}(admin.rgb, admin.a * v_nyans.a);

			}`)
		mb[kompileraSkuggare](snöProgram.skärvSkuggare)
		om(!mb[hämtaSkuggVariabel](snöProgram.skärvSkuggare, mb[KOMPILATIONS_STATUS]), () => {
			notera(mb[hämtaSkuggDeklarationsLoggbok](snöProgram.skärvSkuggare))
			mb[utplånaSkuggare](snöProgram.skärvSkuggare)
			kasta("nåt e fel med snöProgram.skärvskuggaren")
		})
		notera("snöProgram.skärvSkuggare initierad")

		snöProgram.dagordning = mb[skapaDagordning]()

		mb[bifogaSkuggare](snöProgram.dagordning, snöProgram.vertexSkuggare)
		mb[bifogaSkuggare](snöProgram.dagordning, snöProgram.skärvSkuggare)
		mb[länkaDagordning](snöProgram.dagordning)
		
		om(!mb[hämtaDagordningsVariabel](snöProgram.dagordning, mb[LÄNK_STATUS]), () => {
			notera(mb[hämtaDagordningsInformationsLoggbok](snöProgram.dagordning))
			mb[förstörDagordning](snöProgram.dagordning)
			kasta("lyckades ej skapa snöProgram.dagordning")
		})
		mb[användDagordning](snöProgram.dagordning)
		notera("snöProgram.dagordning etablerad")

		kamera = {
			synfält: 80,
			nära: 0,
			långbort: 1000,
			förhållande: 1,
			z: 125,
			perspektiv: sant,
		}

		kamera.synfältsRadianer = kamera.synfält * τ / 360
		kamera.f = Matte.tan(τ * 0.25 - 0.5 * kamera.synfältsRadianer)
		kamera.inverteradRäckvidd = 1.0 / ( kamera.nära - kamera.långbort)

		vinden = {
			nuvarande: 0,
			kraft: 0.1,
			mål: 0.1,
			lägsta: 0.1,
			högsta: 0.25,
			mjukgörare: 0.005
		}
		nej = () => {
			vinden.nuvarande += (vinden.nuvarande - vinden.mål) * 25;
			vinden.mål *= 10;
			vinden.lägsta *= 0.25;
			vinden.högsta *= 4;
			vinden.mjukgörare *= 0.75;

			vinden.mål = ( vinden.lägsta + slump() * ( vinden.högsta - vinden.lägsta ) ) * ( slump() > 0.5 ? -1 : 1 )
		}

		snöProgram.räknare = 0
		snöProgram.buffertar = {}
		snöProgram.buffertInställningar = {
			plats: { längd: 3, innehåll: [] },
			nyans: { längd: 4, innehåll: [] },
			storlek: { längd: 1, innehåll: [] },
			cirkulation: { längd: 3, innehåll: [] },
			hastighet: { längd: 3, innehåll: [] },
		}
		Objekt[poster](snöProgram.buffertInställningar)[förVarje](([namn, inställningar]) => {
			notera("Skapar upp buffert:", namn)
			inställningar.position = mb[hämtaEgenskapsPlats](snöProgram.dagordning, "e_"+namn)
			inställningar.buffert = mb[skapaBuffert]()
			
			mb[snärjBuffert](mb[MATRIS_BUFFER], inställningar.buffert)
			mb[tillgängliggörVertexEgenskapsMatris](inställningar.position)
			mb[vertexEgenskapsPekare](inställningar.position, inställningar.längd, mb[FLYTTAL], falskt, 0, 0)

			Objekt[definieraEgendom](snöProgram.buffertar, namn, {
				[ställ]: värde => {
					inställningar.innehåll = värde
					mb[snärjBuffert](mb[MATRIS_BUFFER], inställningar.buffert)
					mb[buffraInnehåll](mb[MATRIS_BUFFER], nyFlyttals32Matris(värde), mb[STATISK_RITNING])
					om(namn == 'plats', () => {
						snöProgram.räknare = inställningar.innehåll[längd] / 3
					})
				},
				[hämta]: () => inställningar.innehåll
			})
		})
		mb[snärjBuffert](mb[MATRIS_BUFFER], värdelös)

		snöProgram.likformiga = {}
		snöProgram.likformigaInställningar = {
			tid: { typ: 'flyttal', innehåll: [0] },
			noggrannhet: { typ: 'bivektor', innehåll: [ 0, 0 ] },
			projicering: { typ: 'quadmatris', innehåll: [ falskt, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]] },
			jordStorlek: { typ: 'trivektor', innehåll: [ 0, 0, 0 ] },
			newton: { typ: 'flyttal', innehåll: [100] },
			vinden :{ typ: 'flyttal', innehåll: [0] },
		}

		Objekt[poster](snöProgram.likformigaInställningar)[förVarje](([namn, inställningar]) => {
			notera("Skapar upp likformighet:", namn)
			inställningar.plats = mb[hämtaLikformigPlats](snöProgram.dagordning, "l_"+namn)

			Objekt[definieraEgendom](snöProgram.likformiga, namn, {
				[ställ]: värde => {
					inställningar.innehåll = värde
					mb[likformsTyper[inställningar.typ]](inställningar.plats, ...värde)
				},
				[hämta]: () => inställningar.innehåll
			})
			mb[likformsTyper[inställningar.typ]](inställningar.plats, ...inställningar.innehåll)
		})

		notera("skapar upp snöstruktur")
		snöProgram.struktur = mb[skapaStruktur]()
		mb[snärjStruktur](mb[STRUKTUR_2D], snöProgram.struktur)
		mb[strukturBild2D](mb[STRUKTUR_2D], 0, mb.RGBA, 1, 1, 0, mb.RGBA, mb[OSIGNERAD_OKTETT], nyOsigneradHeltalsOktettMatris([0, 0, 0, 0]))

		snöProgram.strukturBild = texturerna.solen;

		snöProgram.strukturBild[påLaddning] = () => {
			notera("läser in struktur")
			mb[snärjStruktur](mb[STRUKTUR_2D], snöProgram.struktur)
			mb[strukturBild2D](mb[STRUKTUR_2D], 0, mb.RGBA, mb.RGBA, mb[OSIGNERAD_OKTETT], snöProgram.strukturBild)
			mb[strukturVariabelHeltal](mb[STRUKTUR_2D], mb[STRUKTUR_MINIFIERINGSSIL], mb[LINJÄR])
			mb[strukturVariabelHeltal](mb[STRUKTUR_2D], mb[STRUKTUR_FÖRSTORINGSSIL], mb[LINJÄR])
			mb[strukturVariabelHeltal](mb[STRUKTUR_2D], mb[STRUKTUR_OMSLAG_S], mb[KLÄMTILL_MOT_KANT])
			mb[strukturVariabelHeltal](mb[STRUKTUR_2D], mb[STRUKTUR_OMSLAG_T], mb[KLÄMTILL_MOT_KANT])
		}

		snöProgram.påOmskalning = (förhållande, fullBredd, fullHöjd) => {


			// z i räckvidden från -55 till 55, kamera avståndet är 125
			// maximal höjd vid z av -55 är oklart som fan
			const jordHöjd = 120
			const jordBredd = förhållande * jordHöjd
			const djup = 55

			snöProgram.likformiga.noggrannhet = [fullBredd, fullHöjd]
			snöProgram.likformiga.projicering = [falskt, om(kamera.perspektiv, () => [
					kamera.f / förhållande, 0, 0, 0,
					0, kamera.f, 0, 0,
					0, 0, (kamera.nära + kamera.långbort) * kamera.inverteradRäckvidd, -1,
					0, 0, kamera.nära * kamera.långbort * kamera.inverteradRäckvidd * 2 + kamera.z, kamera.z
				], () => [
					2 / fullBredd, 0, 0, 0,
					0, -2 / fullHöjd, 0, 0,
					0, 0, 1, 0,
					-1, 1, 0, 1,
				])]
			snöProgram.likformiga.jordStorlek = [ jordBredd, jordHöjd, djup ]
			
			enhetsVärden = {
				plats: [],
				nyans: [],
				storlek: [],
				cirkulation: [],
				hastighet: [],
			}

			Matris[från]( { length: förhållande * slumpa(500, 2500) }, admin =>  {

				enhetsVärden.plats[knuffa](
					-jordBredd + slump() * jordBredd * 2,
					-jordHöjd + slump() * jordHöjd * 2,
					slump() * djup * 2
				)

				enhetsVärden.hastighet[knuffa](// 0, 0, 0 )
					1 + slump(),
					1 + slump(),
					slump() * 10
				) // x, y, sinusformad

				enhetsVärden.cirkulation[knuffa](
					slump() * 2 * τ,
					slump() * 20,
					slump() * 10
				) // vinkel, hastighet, sinusformad

				enhetsVärden.nyans[knuffa](
					1,
					1,
					1,
					0.2 + slump() * 0.5
				)

				enhetsVärden.storlek[knuffa](
					5 * slump() * 5 * ( fullHöjd * ppt / 1000 )
				)

			} )

			snöProgram.buffertar.plats = enhetsVärden.plats
			snöProgram.buffertar.nyans = enhetsVärden.nyans
			snöProgram.buffertar.cirkulation = enhetsVärden.cirkulation
			snöProgram.buffertar.storlek = enhetsVärden.storlek
			snöProgram.buffertar.hastighet = enhetsVärden.hastighet
		}


		snöProgram.rita = (delta, förflutit) => {
			snöProgram.likformiga.tid = [förflutit]
			snöProgram.likformiga.vinden = [vinden.nuvarande]
			om(snöProgram.räknare > 0, () => {
				// mb[rensa](mb[NYANSBUFFERBIT]) // Detta genererar ett prestandavarsel när det är där, och verkar inte behövas?
				mb[möjliggör](mb[SAMMANSMÄLTNING])
				mb[möjliggör](mb[GALLRA_YTA])
				mb[sammansmältningsFunktion](mb[KÄLLA_OGENOMSKINLIGHET], mb[ETT])
				mb[stängAv](mb[DJUP_TEST])
				mb[ritaMatriser](mb[PUNKTER], 0, snöProgram.räknare)
			})
		}





		nyttProgram = (vertexSkuggare, skärvSkuggare, likformigaInställningar, ritAnrop = () => {}) => {
			program = {}
			program.buffrar = {};
			program.likformiga = {};


			program.vertexSkuggare = mb[skapaSkuggare](mb[VERTEX_SKUGGARE])
			mb[skuggarKälla](program.vertexSkuggare, vertexSkuggare)

			program.skärvSkuggare = mb[skapaSkuggare](mb[SKÄRV_SKUGGARE])
			mb[skuggarKälla](program.skärvSkuggare, skärvSkuggare)

			program.likformiga = {};

			Objekt[poster](likformigaInställningar)[förVarje](([namn, inställningar]) => {
				notera("Skapar upp likformighet:", namn)
				inställningar.plats = mb[hämtaLikformigPlats](program.dagordning, "l_"+namn)
				mb[likformsTyper[inställningar.typ]](inställningar.plats, ...inställningar.innehåll)
			})




			program.dagordning = mb[skapaDagordning]();

			mb[bifogaSkuggare](program.dagordning, program.vertexSkuggare)
			mb[bifogaSkuggare](program.dagordning, program.skärvSkuggare)
			mb[länkaDagordning](program.dagordning)

			program.rita = (delta, förflutit) => {

				
				ritAnrop(program, delta, förflutit)

				Objekt[poster](likformigaInställningar)[förVarje](([namn, inställningar]) => {
					mb[likformsTyper[inställningar.typ]](inställningar.plats, ...program.likformiga[namn])
				})

				mb[ritaMatriser](mb[PUNKTER], 0, program.antalObjekt)
			}

			return program
		}


		// snöProgram = nyttProgram(
		// 	vertexSkuggare,
		// 	skärvSkuggare,
		// 	{
		// 		tid: { typ: 'flyttal', innehåll: [0] },
		// 		noggrannhet: { typ: 'bivektor', innehåll: [ 0, 0 ] },
		// 		projicering: { typ: 'quadmatris', innehåll: [ falskt, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]] },
		// 		jordStorlek: { typ: 'trivektor', innehåll: [ 0, 0, 0 ] },
		// 		newton: { typ: 'flyttal', innehåll: [100] },
		// 		vinden :{ typ: 'flyttal', innehåll: [0] },
		// 	},
		// )



		dagordningar = [
			snöProgram,
		];

		påOmskalning = () => {
			fullBredd = behållaren[kompensationsBredd]
			fullHöjd = behållaren[kompensationsHöjd]
			förhållande = fullBredd / fullHöjd
			ppt = Matte.max(1, devicePixelRatio)

			målarduken[bredd] = fullBredd
			målarduken[höjd] = fullHöjd
			målarduken[stil][bredd] = fullBredd
			målarduken[stil][höjd] = fullHöjd

			mb[fönsterHamn](0, 0, fullBredd * ppt, fullHöjd * ppt)
			mb[rengörNyans](0, 0, 0, 0)

			dagordningar[förVarje]((dagordning) => {
				dagordning.påOmskalning(förhållande, fullBredd, fullHöjd)
			})
		}
		fönster[läggTillHändelseSpanare](omskalning, påOmskalning, falskt)
		påOmskalning()

		tiden = { början: prestanda[nu](), gamla: prestanda[nu]() }
		ö = 0;
		uppdatera = () => {
			ö++
			aktuellt = prestanda[nu]()
			förflutit = (aktuellt - tiden.början) / 5000
			delta = aktuellt - tiden.gamla
			tiden.gamla = aktuellt
			vinden.kraft += ( vinden.mål - vinden.kraft ) * vinden.mjukgörare
			vinden.nuvarande += vinden.kraft * ( delta * 0.2 )

			om( slump() > 0.995, () => {
				vinden.mål = ( vinden.lägsta + slump() * ( vinden.högsta - vinden.lägsta ) ) * ( slump() > 0.5 ? -1 : 1 )
			})
			dagordningar[förVarje]((dagordning) => {
				dagordning.rita(delta, förflutit)
			})
			begärAnimationsRuta(uppdatera)
		}
		uppdatera()
	})


	målet = Datum(2021, 11, 12, 13, 37, 0)[hämtaTid]()
	placeraMellanakt(() => {
		kvar = målet - Datum()[hämtaTid]();
		passerat = kvar < 0;
		kvar = absolut(kvar)
		totti_tiondeli = golva(kvar / 100)
		tiondelar = totti_tiondeli % 10
		totti_sekundi = golva(totti_tiondeli / 10)
		sekunder = totti_sekundi % 60
		totti_minuti = golva(totti_sekundi / 60)
		minuter = totti_minuti % 60
		totti_timmi = golva(totti_minuti / 60)
		timmar = totti_timmi % 24
		dagar = golva(totti_timmi / 24)
		fönster["nedräkning"][invändigÖOPS] = `${passerat?'-':''}${dagar} ${timmar.toString().padStart(2, "0")}:${minuter.toString().padStart(2, "0")}:${sekunder.toString().padStart(2, "0")}.${tiondelar}`
	}, 50)
	
</script>

</html>