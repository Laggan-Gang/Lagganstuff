<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "https://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html lang="sga" xmlns="https://www.w3.org/1999/xhtml">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>13 DAYS OF LAGGAN HOLIDAYS</title>
	<link rel="stylesheet" href="https://unpkg.com/sanitize.css" media="print" onload="this.media='all'" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/comic-mono@0.0.1/index.css" media="print" onload="this.media='all'" />
	<link rel="icon" href="favicon.ico">
	<style type="text/css">
		body {
			padding: 0;
		}
		#behållare {
			width: 100vw;
			height: 100vh;
			overflow: hidden;
		}
		#nedräkning, #fotnot, .nedräkning {
			white-space: nowrap;
			text-align: center;
		}
		#nedräkning, .nedräkning {
			top: 35%;
			font-size: 13vw;
		}
		#fotnot {
			font-size: 4vw;
		}
		#omslagspappret {
			position: relative;
			/* background-image: url("/lagganmas/bakgrund.jpg"); */
			background-size: cover;
			width: 100%;
			height: 100%;
			/* width: 1920px; */
			/* height: 1080px; */
			margin: 0 auto;
			overflow-y: auto;
		}
		#snön, #Зареждане {
			background-size: cover;
			display: block;
			position: fixed;
			left: 0;
			top: 0;
			right: 0;
			bottom: 0;
		}
		#Зареждане {
			display: fixed;
			background: #000;
			overflow: hidden;
		}
		.sara {
			position: absolute;
			background-image: url("/lagganmas/lina.png");
			background-size: cover;
			/* padding-top: 150%; */
			width: 2vw;
			height: 3vw;
		}
		.date {
			display: inline-block;
			width: 100%;
			white-space: nowrap;
			text-align: center;
		}
		.omslagspapper {
			width: 100%;
			overflow-x: auto;
		}
		#kalendarium {
			display: inline-block;
			background: rgba(0,0,0,0.2);
			padding: 10px;
			width: 1610px;
			margin: 0 auto 0;
			display: grid;
			grid-gap: 5px;
			align-items: baseline;
			grid-template-columns: repeat(8, 1fr);
		}
		#kalendarium>div {
			border: 2px solid;
			padding: 5px;
			place-self: stretch;
		}
		#kalendarium>:nth-child(16n + 1),
		#kalendarium>:nth-child(16n + 3),
		#kalendarium>:nth-child(16n + 5),
		#kalendarium>:nth-child(16n + 7),
		#kalendarium>:nth-child(16n + 9),
		#kalendarium>:nth-child(16n + 11),
		#kalendarium>:nth-child(16n + 13),
		#kalendarium>:nth-child(16n + 15)
		{
			border-color: red;
			border-style: dashed;
		}
		#kalendarium>:nth-child(16n + 2),
		#kalendarium>:nth-child(16n + 4),
		#kalendarium>:nth-child(16n + 6),
		#kalendarium>:nth-child(16n + 8),
		#kalendarium>:nth-child(16n + 10),
		#kalendarium>:nth-child(16n + 12),
		#kalendarium>:nth-child(16n + 14),
		#kalendarium>:nth-child(16n + 16)
		{
			border-color: green;
			border-style: dotted;
		}
		#kalendarium>.noop {
			border: none;
		}
		#kalendarium>.spacer {
			grid-column: 1 / span 8;
			text-align: center;
		}
		#kalendarium>.minigame {
			grid-column: 2 / span 3;
		}
		#kalendarium>.minigame2 {
			grid-column: 6 / span 3;
		}
		ul.festive>:nth-child(even), .red {
			color: red;
		}
		ul.festive>:nth-child(odd), .green {
			color: green;
		}
		.minigame {
			margin: 50px auto;
			padding: 20px;
			background: rgba(0,0,0,0.2);
		}
	</style>
	<script type="text/javascript">
		skit_i_animering = 1
	</script>
	<!-- <script src="https://greggman.github.io/webgl-lint/webgl-lint.js" crossorigin></script> -->
	<script type="text/javascript" src="UngeMozartdenjäveln.js"></script>
</head>

<body>
	<div id="behållare">
		<div id="snön"></div>
	</div>
</body>
<script type="text/javascript">
	// kraftigt inspirerad av https://github.com/bsehovac/shader-program

	behållaren = hämtaRadiatorEfterLegitimation('snön')
	målarduken = skapaElement( målarduk )
	mb = målarduken[hämtaSammanhang]( nätmb, { antialias: sant } )

	texturerna = {}
	texturerAttLaddaTotti = 0;
	texturerAttLadda = 0;

	skapaBildTextur = (namn, källPlats, element = falskt, cb = () => {}) => {
		bilden = nyBild(källPlats)
		texturerAttLadda++;
		texturerAttLaddaTotti++;
		bilden[läggTillHändelseSpanare](ladda, () => {

			texturerAttLadda--;
			notera(`${källPlats} laddad, ${texturerAttLadda} kvar`)
	            cb();
			om(element, ()=>{ hämtaRadiatorEfterLegitimation(element)[stil][bakgrundsBild] = `${sökväg}(${källPlats})` })
		})
		texturerna[namn] = bilden;
	}

	skapaBildTextur("bakgrunden", '/lagganmas/bakgrund.jpg', "snön")
	skapaBildTextur("solen", '/lagganmas/solen.png')

	om(mb, () => {
		behållaren[bifogaBarn](målarduken)
		
		snöProgram = {};
		snöProgram.vertexSkuggare = mb[skapaSkuggare](mb[VERTEX_SKUGGARE])
		mb[skuggarKälla](snöProgram.vertexSkuggare, `
			${noggrannhet} ${högn} ${flyttal};

			${egenskap} ${quadvektor} e_plats;
			${egenskap} ${quadvektor} e_nyans;
			${egenskap} ${trivektor} e_cirkulation;
			${egenskap} ${trivektor} e_hastighet;
			${egenskap} ${flyttal} e_storlek;

			${likformig} ${flyttal} l_tid;
			${likformig} ${bivektor} l_noggrannhet;
			${likformig} ${quadmatris} l_projicering;
			${likformig} ${trivektor} l_jordStorlek;
			${likformig} ${flyttal} l_newton;
			${likformig} ${flyttal} l_vinden;

			${brokig} ${quadvektor} v_nyans;
			${brokig} ${flyttal} v_cirkulation;

			${tomhet} ${huvud}() {

				v_nyans = e_nyans;
				v_cirkulation = e_cirkulation.x + l_tid * e_cirkulation.y;

				${trivektor} plats = e_plats.xyz;

				plats.x = mod(plats.x + l_tid + l_vinden * e_hastighet.x, l_jordStorlek.x * 2.0) - l_jordStorlek.x;
				plats.y = mod(plats.y - l_tid * e_hastighet.y * l_newton, l_jordStorlek.y * 2.0) - l_jordStorlek.y;

				plats.x += sin(l_tid * e_hastighet.z) * e_cirkulation.z;
				plats.z += cos(l_tid * e_hastighet.z) * e_cirkulation.z;

				${mb_Plats} = l_projicering * ${quadvektor}( plats.xyz, e_plats.w );
				${mb_PunktStorlek} = ( e_storlek / ${mb_Plats}.w ) * 100.0;

			}`)
		mb[kompileraSkuggare](snöProgram.vertexSkuggare)
		om(!mb[hämtaSkuggVariabel](snöProgram.vertexSkuggare, mb[KOMPILATIONS_STATUS]), () => {
			notera(mb[hämtaSkuggDeklarationsLoggbok](snöProgram.vertexSkuggare))
			mb[utplånaSkuggare](snöProgram.vertexSkuggare)
			kasta("nåt gick fel vid skapandet av snöProgram.vertexskuggaren")
		})
		notera("snöProgram.vertexSkuggare initierad")

		snöProgram.skärvSkuggare = mb[skapaSkuggare](mb[SKÄRV_SKUGGARE])
		mb[skuggarKälla](snöProgram.skärvSkuggare, `
			${noggrannhet} ${högn} ${flyttal};

			${likformig} ${provtagare2D} u_struktur;

			${brokig} ${quadvektor} v_nyans;
			${brokig} ${flyttal} v_cirkulation;

			${tomhet} ${huvud}() {

				${bivektor} cirkulerad = ${bivektor}(
					cos(v_cirkulation) * (${mb_PunktPlats}.x - 0.5) + sin(v_cirkulation) * (${mb_PunktPlats}.y - 0.5) + 0.5,
					cos(v_cirkulation) * (${mb_PunktPlats}.y - 0.5) - sin(v_cirkulation) * (${mb_PunktPlats}.x - 0.5) + 0.5
				);

				${quadvektor} admin = ${struktur2D}(u_struktur, cirkulerad);

				${mb_SkärvNyans} = ${quadvektor}(admin.rgb, admin.a * v_nyans.a);

			}`)
		mb[kompileraSkuggare](snöProgram.skärvSkuggare)
		om(!mb[hämtaSkuggVariabel](snöProgram.skärvSkuggare, mb[KOMPILATIONS_STATUS]), () => {
			notera(mb[hämtaSkuggDeklarationsLoggbok](snöProgram.skärvSkuggare))
			mb[utplånaSkuggare](snöProgram.skärvSkuggare)
			kasta("nåt e fel med snöProgram.skärvskuggaren")
		})
		notera("snöProgram.skärvSkuggare initierad")

		snöProgram.dagordning = mb[skapaDagordning]()

		mb[bifogaSkuggare](snöProgram.dagordning, snöProgram.vertexSkuggare)
		mb[bifogaSkuggare](snöProgram.dagordning, snöProgram.skärvSkuggare)
		mb[länkaDagordning](snöProgram.dagordning)
		
		om(!mb[hämtaDagordningsVariabel](snöProgram.dagordning, mb[LÄNK_STATUS]), () => {
			notera(mb[hämtaDagordningsInformationsLoggbok](snöProgram.dagordning))
			mb[förstörDagordning](snöProgram.dagordning)
			kasta("lyckades ej skapa snöProgram.dagordning")
		})
		mb[användDagordning](snöProgram.dagordning)
		notera("snöProgram.dagordning etablerad")

		kamera = {
			synfält: 80,
			nära: 0,
			långbort: 1000,
			förhållande: 1,
			z: 125,
			perspektiv: sant,
		}

		kamera.synfältsRadianer = kamera.synfält * τ / 360
		kamera.f = Matte.tan(τ * 0.25 - 0.5 * kamera.synfältsRadianer)
		kamera.inverteradRäckvidd = 1.0 / ( kamera.nära - kamera.långbort)

		vinden = {
			nuvarande: 0,
			kraft: 0.1,
			mål: 0.1,
			lägsta: 0.1,
			högsta: 0.25,
			mjukgörare: 0.005
		}
		nej = () => {
			vinden.nuvarande += (vinden.nuvarande - vinden.mål) * 25;
			vinden.mål *= 10;
			vinden.lägsta *= 0.25;
			vinden.högsta *= 4;
			vinden.mjukgörare *= 0.75;

			vinden.mål = ( vinden.lägsta + slump() * ( vinden.högsta - vinden.lägsta ) ) * ( slump() > 0.5 ? -1 : 1 )
		}

		snöProgram.räknare = 0
		snöProgram.buffertar = {}
		snöProgram.buffertInställningar = {
			plats: { längd: 3, innehåll: [] },
			nyans: { längd: 4, innehåll: [] },
			storlek: { längd: 1, innehåll: [] },
			cirkulation: { längd: 3, innehåll: [] },
			hastighet: { längd: 3, innehåll: [] },
		}
		Objekt[poster](snöProgram.buffertInställningar)[förVarje](([namn, inställningar]) => {
			notera("Skapar upp buffert:", namn)
			inställningar.position = mb[hämtaEgenskapsPlats](snöProgram.dagordning, "e_"+namn)
			inställningar.buffert = mb[skapaBuffert]()
			
			mb[snärjBuffert](mb[MATRIS_BUFFER], inställningar.buffert)
			mb[tillgängliggörVertexEgenskapsMatris](inställningar.position)
			mb[vertexEgenskapsPekare](inställningar.position, inställningar.längd, mb[FLYTTAL], falskt, 0, 0)

			Objekt[definieraEgendom](snöProgram.buffertar, namn, {
				[ställ]: värde => {
					inställningar.innehåll = värde
					mb[snärjBuffert](mb[MATRIS_BUFFER], inställningar.buffert)
					mb[buffraInnehåll](mb[MATRIS_BUFFER], nyFlyttals32Matris(värde), mb[STATISK_RITNING])
					om(namn == 'plats', () => {
						snöProgram.räknare = inställningar.innehåll[längd] / 3
					})
				},
				[hämta]: () => inställningar.innehåll
			})
		})
		mb[snärjBuffert](mb[MATRIS_BUFFER], värdelös)

		snöProgram.likformiga = {}
		snöProgram.likformigaInställningar = {
			tid: { typ: 'flyttal', innehåll: [0] },
			noggrannhet: { typ: 'bivektor', innehåll: [ 0, 0 ] },
			projicering: { typ: 'quadmatris', innehåll: [ falskt, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]] },
			jordStorlek: { typ: 'trivektor', innehåll: [ 0, 0, 0 ] },
			newton: { typ: 'flyttal', innehåll: [100] },
			vinden :{ typ: 'flyttal', innehåll: [0] },
		}

		Objekt[poster](snöProgram.likformigaInställningar)[förVarje](([namn, inställningar]) => {
			notera("Skapar upp likformighet:", namn)
			inställningar.plats = mb[hämtaLikformigPlats](snöProgram.dagordning, "l_"+namn)

			Objekt[definieraEgendom](snöProgram.likformiga, namn, {
				[ställ]: värde => {
					inställningar.innehåll = värde
					mb[likformsTyper[inställningar.typ]](inställningar.plats, ...värde)
				},
				[hämta]: () => inställningar.innehåll
			})
			mb[likformsTyper[inställningar.typ]](inställningar.plats, ...inställningar.innehåll)
		})

		notera("skapar upp snöstruktur")
		snöProgram.struktur = mb[skapaStruktur]()
		mb[snärjStruktur](mb[STRUKTUR_2D], snöProgram.struktur)
		mb[strukturBild2D](mb[STRUKTUR_2D], 0, mb.RGBA, 1, 1, 0, mb.RGBA, mb[OSIGNERAD_OKTETT], nyOsigneradHeltalsOktettMatris([0, 0, 0, 0]))

		snöProgram.strukturBild = texturerna.solen;

		snöProgram.strukturBild[påLaddning] = () => {
			notera("läser in struktur")
			mb[snärjStruktur](mb[STRUKTUR_2D], snöProgram.struktur)
			mb[strukturBild2D](mb[STRUKTUR_2D], 0, mb.RGBA, mb.RGBA, mb[OSIGNERAD_OKTETT], snöProgram.strukturBild)
			mb[strukturVariabelHeltal](mb[STRUKTUR_2D], mb[STRUKTUR_MINIFIERINGSSIL], mb[LINJÄR])
			mb[strukturVariabelHeltal](mb[STRUKTUR_2D], mb[STRUKTUR_FÖRSTORINGSSIL], mb[LINJÄR])
			mb[strukturVariabelHeltal](mb[STRUKTUR_2D], mb[STRUKTUR_OMSLAG_S], mb[KLÄMTILL_MOT_KANT])
			mb[strukturVariabelHeltal](mb[STRUKTUR_2D], mb[STRUKTUR_OMSLAG_T], mb[KLÄMTILL_MOT_KANT])
		}

		snöProgram.påOmskalning = (förhållande, fullBredd, fullHöjd) => {


			// z i räckvidden från -55 till 55, kamera avståndet är 125
			// maximal höjd vid z av -55 är oklart som fan
			const jordHöjd = 120
			const jordBredd = förhållande * jordHöjd
			const djup = 55

			snöProgram.likformiga.noggrannhet = [fullBredd, fullHöjd]
			snöProgram.likformiga.projicering = [falskt, om(kamera.perspektiv, () => [
					kamera.f / förhållande, 0, 0, 0,
					0, kamera.f, 0, 0,
					0, 0, (kamera.nära + kamera.långbort) * kamera.inverteradRäckvidd, -1,
					0, 0, kamera.nära * kamera.långbort * kamera.inverteradRäckvidd * 2 + kamera.z, kamera.z
				], () => [
					2 / fullBredd, 0, 0, 0,
					0, -2 / fullHöjd, 0, 0,
					0, 0, 1, 0,
					-1, 1, 0, 1,
				])]
			snöProgram.likformiga.jordStorlek = [ jordBredd, jordHöjd, djup ]
			
			enhetsVärden = {
				plats: [],
				nyans: [],
				storlek: [],
				cirkulation: [],
				hastighet: [],
			}

			Matris[från]( { length: förhållande * slumpa(500, 2500) }, admin =>  {

				enhetsVärden.plats[knuffa](
					-jordBredd + slump() * jordBredd * 2,
					-jordHöjd + slump() * jordHöjd * 2,
					slump() * djup * 2
				)

				enhetsVärden.hastighet[knuffa](// 0, 0, 0 )
					1 + slump(),
					1 + slump(),
					slump() * 10
				) // x, y, sinusformad

				enhetsVärden.cirkulation[knuffa](
					slump() * 2 * τ,
					slump() * 20,
					slump() * 10
				) // vinkel, hastighet, sinusformad

				enhetsVärden.nyans[knuffa](
					1,
					1,
					1,
					0.2 + slump() * 0.5
				)

				enhetsVärden.storlek[knuffa](
					5 * slump() * 5 * ( fullHöjd * ppt / 1000 )
				)

			} )

			snöProgram.buffertar.plats = enhetsVärden.plats
			snöProgram.buffertar.nyans = enhetsVärden.nyans
			snöProgram.buffertar.cirkulation = enhetsVärden.cirkulation
			snöProgram.buffertar.storlek = enhetsVärden.storlek
			snöProgram.buffertar.hastighet = enhetsVärden.hastighet
		}


		snöProgram.rita = (delta, förflutit) => {
			snöProgram.likformiga.tid = [förflutit]
			snöProgram.likformiga.vinden = [vinden.nuvarande]
			om(snöProgram.räknare > 0, () => {
				// mb[rensa](mb[NYANSBUFFERBIT]) // Detta genererar ett prestandavarsel när det är där, och verkar inte behövas?
				mb[möjliggör](mb[SAMMANSMÄLTNING])
				mb[möjliggör](mb[GALLRA_YTA])
				mb[sammansmältningsFunktion](mb[KÄLLA_OGENOMSKINLIGHET], mb[ETT])
				mb[stängAv](mb[DJUP_TEST])
				mb[ritaMatriser](mb[PUNKTER], 0, snöProgram.räknare)
			})
		}





		nyttProgram = (vertexSkuggare, skärvSkuggare, likformigaInställningar, ritAnrop = () => {}) => {
			program = {}
			program.buffrar = {};
			program.likformiga = {};


			program.vertexSkuggare = mb[skapaSkuggare](mb[VERTEX_SKUGGARE])
			mb[skuggarKälla](program.vertexSkuggare, vertexSkuggare)

			program.skärvSkuggare = mb[skapaSkuggare](mb[SKÄRV_SKUGGARE])
			mb[skuggarKälla](program.skärvSkuggare, skärvSkuggare)

			program.likformiga = {};

			Objekt[poster](likformigaInställningar)[förVarje](([namn, inställningar]) => {
				notera("Skapar upp likformighet:", namn)
				inställningar.plats = mb[hämtaLikformigPlats](program.dagordning, "l_"+namn)
				mb[likformsTyper[inställningar.typ]](inställningar.plats, ...inställningar.innehåll)
			})




			program.dagordning = mb[skapaDagordning]();

			mb[bifogaSkuggare](program.dagordning, program.vertexSkuggare)
			mb[bifogaSkuggare](program.dagordning, program.skärvSkuggare)
			mb[länkaDagordning](program.dagordning)

			program.rita = (delta, förflutit) => {

				
				ritAnrop(program, delta, förflutit)

				Objekt[poster](likformigaInställningar)[förVarje](([namn, inställningar]) => {
					mb[likformsTyper[inställningar.typ]](inställningar.plats, ...program.likformiga[namn])
				})

				mb[ritaMatriser](mb[PUNKTER], 0, program.antalObjekt)
			}

			return program
		}


		// snöProgram = nyttProgram(
		// 	vertexSkuggare,
		// 	skärvSkuggare,
		// 	{
		// 		tid: { typ: 'flyttal', innehåll: [0] },
		// 		noggrannhet: { typ: 'bivektor', innehåll: [ 0, 0 ] },
		// 		projicering: { typ: 'quadmatris', innehåll: [ falskt, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]] },
		// 		jordStorlek: { typ: 'trivektor', innehåll: [ 0, 0, 0 ] },
		// 		newton: { typ: 'flyttal', innehåll: [100] },
		// 		vinden :{ typ: 'flyttal', innehåll: [0] },
		// 	},
		// )



		dagordningar = [
			snöProgram,
		];

		påOmskalning = () => {
			fullBredd = behållaren[kompensationsBredd]
			fullHöjd = behållaren[kompensationsHöjd]
			förhållande = fullBredd / fullHöjd
			ppt = Matte.max(1, devicePixelRatio)

			målarduken[bredd] = fullBredd
			målarduken[höjd] = fullHöjd
			målarduken[stil][bredd] = fullBredd
			målarduken[stil][höjd] = fullHöjd

			mb[fönsterHamn](0, 0, fullBredd * ppt, fullHöjd * ppt)
			mb[rengörNyans](0, 0, 0, 0)

			dagordningar[förVarje]((dagordning) => {
				dagordning.påOmskalning(förhållande, fullBredd, fullHöjd)
			})
		}
		fönster[läggTillHändelseSpanare](omskalning, påOmskalning, falskt)
		påOmskalning()

		tiden = { början: prestanda[nu](), gamla: prestanda[nu]() }
		ö = 0;
		uppdatera = () => {
			ö++
			aktuellt = prestanda[nu]()
			förflutit = (aktuellt - tiden.början) / 5000
			delta = aktuellt - tiden.gamla
			tiden.gamla = aktuellt
			vinden.kraft += ( vinden.mål - vinden.kraft ) * vinden.mjukgörare
			vinden.nuvarande += vinden.kraft * ( delta * 0.2 )

			om( slump() > 0.995, () => {
				vinden.mål = ( vinden.lägsta + slump() * ( vinden.högsta - vinden.lägsta ) ) * ( slump() > 0.5 ? -1 : 1 )
			})
			dagordningar[förVarje]((dagordning) => {
				dagordning.rita(delta, förflutit)
			})
			begärAnimationsRuta(uppdatera)
		}
		uppdatera()
	})


	
</script>

</html>